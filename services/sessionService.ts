
import { supabase } from './supabaseClient';
import type { Session, SeoSuggestion } from '../types';
import type { User } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid'; // Simple UUID generation

const LOCAL_STORAGE_KEY = 'clearCueSessions';

/**
 * Recursively sanitizes an object to remove null characters (\u0000) from strings,
 * which are not allowed in Postgres jsonb columns and can be generated by LLMs.
 * @param data The data to sanitize (any type).
 * @returns The sanitized data.
 */
const sanitizeForPostgres = (data: any): any => {
    if (data === null || data === undefined) {
        return data;
    }
    if (Array.isArray(data)) {
        return data.map(item => sanitizeForPostgres(item));
    }
    if (typeof data === 'object') {
        const sanitizedObject: { [key: string]: any } = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                sanitizedObject[key] = sanitizeForPostgres(data[key]);
            }
        }
        return sanitizedObject;
    }
    if (typeof data === 'string') {
        // Replace the null character, which Postgres jsonb cannot handle.
        return data.replace(/\u0000/g, ''); 
    }
    return data;
};

// Maps DB result (snake_case) to frontend Session object (camelCase)
const sessionFromDb = (dbData: any): Session => {
    return {
        id: dbData.id,
        user_id: dbData.user_id,
        created_at: dbData.created_at,
        videoTitle: dbData.video_title,
        videoData: dbData.video_data,
        analysisResult: dbData.analysis_result,
        seoSuggestions: dbData.seo_suggestions,
    };
};


// --- Local Storage Functions ---

const getLocalSessions = (): Session[] => {
    try {
        const localData = localStorage.getItem(LOCAL_STORAGE_KEY);
        return localData ? JSON.parse(localData) : [];
    } catch (error) {
        console.error("Failed to parse local sessions:", error);
        return [];
    }
};

const saveLocalSessions = (sessions: Session[]) => {
    try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(sessions));
    } catch (error) {
        console.error("Failed to save local sessions:", error);
    }
};


// --- Unified Service Functions ---

export const getSessions = async (user: User | null): Promise<Session[]> => {
    if (user) {
        const { data, error } = await supabase
            .from('sessions')
            .select('*')
            .order('created_at', { ascending: false });
        if (error) {
            console.error('Error fetching Supabase sessions:', error);
            return [];
        }
        return data.map(sessionFromDb);
    } else {
        return getLocalSessions();
    }
};

export const saveSession = async (
    sessionData: Omit<Session, 'id' | 'user_id' | 'created_at'>, 
    user: User | null
): Promise<Session> => {
    // Sanitize data before sending it to the database to prevent errors with invalid characters.
    const sanitizedData = sanitizeForPostgres(sessionData);

    if (user) {
        // Explicitly map from camelCase (app) to snake_case (db)
        const dbPayload = {
            user_id: user.id,
            video_title: sanitizedData.videoTitle,
            video_data: sanitizedData.videoData,
            analysis_result: sanitizedData.analysisResult,
            seo_suggestions: sanitizedData.seoSuggestions,
        };

        const { data, error } = await supabase
            .from('sessions')
            .insert(dbPayload)
            .select()
            .single();

        if (error) {
            console.error('Error saving session to Supabase:', error);
            throw error;
        }
        return sessionFromDb(data);
    } else {
        const sessions = getLocalSessions();
        const newSession: Session = {
            ...(sanitizedData as Omit<Session, 'id' | 'user_id' | 'created_at'>),
            id: uuidv4(),
            created_at: new Date().toISOString(),
        };
        sessions.unshift(newSession); // Add to the beginning
        saveLocalSessions(sessions.slice(0, 10)); // Keep only the latest 10
        return newSession;
    }
};

export const updateSessionSuggestions = async (
    sessionId: string,
    suggestions: SeoSuggestion[],
    user: User | null
): Promise<void> => {
    // Also sanitize suggestions before updating
    const sanitizedSuggestions = sanitizeForPostgres(suggestions);

    if (user) {
        const { error } = await supabase
            .from('sessions')
            .update({ seo_suggestions: sanitizedSuggestions })
            .eq('id', sessionId)
            .eq('user_id', user.id);

        if (error) {
            console.error('Error updating session suggestions in Supabase:', error);
            throw error;
        }
    } else {
        const sessions = getLocalSessions();
        const sessionIndex = sessions.findIndex(s => s.id === sessionId);
        if (sessionIndex > -1) {
            sessions[sessionIndex].seoSuggestions = sanitizedSuggestions;
            saveLocalSessions(sessions);
        }
    }
};

export const deleteSession = async (sessionId: string, user: User | null): Promise<void> => {
    if (user) {
        const { error } = await supabase.from('sessions').delete().match({ id: sessionId, user_id: user.id });
        if (error) {
            console.error('Error deleting Supabase session:', error);
        }
    } else {
        let sessions = getLocalSessions();
        sessions = sessions.filter(s => s.id !== sessionId);
        saveLocalSessions(sessions);
    }
};

export const deleteAllSessions = async (user: User | null): Promise<void> => {
    if (user) {
        const { error } = await supabase.from('sessions').delete().eq('user_id', user.id);
        if (error) {
            console.error('Error deleting all Supabase sessions:', error);
            throw error;
        }
    } else {
        saveLocalSessions([]);
    }
};
